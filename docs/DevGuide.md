# Руководство к созданию новых нодов

Ноды NVP построены на парадигме функционального программирования: отсутствует явное понятие нодов-классов и нодов-свойств/методов класса, как было, например, в среде визуального программирования Autodesk Dynamo. Каждый нод представляет собой отдельную логическую сущность, получающую (или не получающую), обрабатывающую и возвращающую результат (пусть даже null или 0).

Типовой нод должен быть реализован в виде класса, реализующего интерфейс NVP.API.Nodes.INode:

```cs
public class FooNode : NVP.API.Nodes.INode
{
    public NodeResult Execute(INVPData context, List<NodeResult> inputs)
    {
        return new NodeResult(1);
    }
}
```

Пространство имён NVP.API.Nodes подключается при обращении к `C:\Program Files\NVP\net6.0\NVP.Core.API.dll`если разработка ведется под `net6.0` и к `C:\Program Files\NVP\framework4.8\NVP.API.dll`, если разработка на `net48`.

Так как создание новых нодов часто связано с решением отдельных задач конкретной предметной области, удобно работать с принципами ООП в части создания новых нодов. Рассмотрим, как это наиболее удобно реализовать.

## Для ООП-библиотек и ООП-логики

В силу отсутствия в NVP в явном виде классов, заменим класс на подпространство имён, чтобы конструкторы и методы/свойства создаваемого класса лежали в одной группе нодов в среде NVP. Например, желая работать с классом `CAD.Document` в пространстве имён `MyLibrary`для нодов введем новое пространство имён `MyLibrary.Document`. Под условным пространством имён `CAD`будем понимать некое целевое приложение.

Ноды, которым предполагается отдать роль Конструкторов класса, должны быть реализованы с полем, содержащим объект целевого класса:

```cs
public class Document_Constructor : INode
{
    public CAD.Document _doc;
    public NodeResult Execute(INVPData context, List<NodeResult> inputs)
    {
        _doc = new CAD.Document();
        return new NodeResult(this);
    }
}
```

Ноды, которым предполагается отдать роль методов или свойств класса, должны иметь обязательный NodeInput в виде конструктора класса (содержащего объект класса). При этом `{ get; set;}` модификаторы желательно добавлять как префикс к создаваемому свойству:

```cs
//Для получения свойства Name
[NodeInput("Document", typeof(object))]
public class Get_Name : INode
{
    public CAD.Document _doc;
    public NodeResult Execute(INVPData context, List<NodeResult> inputs)
    {
        dynamic _input0 = inputs[0].Value;
        return new NodeResult(_input0._doc.Name);
    }
}

//Для задания свойства Name
[NodeInput("Document", typeof(object))]
[NodeInput("Name", typeof(string))]
public class Set_Name : INode
{
    public CAD.Document _doc;
    public NodeResult Execute(INVPData context, List<NodeResult> inputs)
    {
        dynamic _input0 = inputs[0].Value;
        _input0._doc.Name = inputs[1].Value as string;
        return new NodeResult(0); //или null, или _doc (по ситуации)
    }
}
```

Здесь как вы можете видеть, сперва получается объект целевого класса `_input0` с модификатором **dynamic**, так как в NodeResult объекты лежат обезличенно с типом `object`. Далее вызывается публичное поле *_doc* и к нему применяется действие -- получение или задание некоего свойства. 

## Для COM-библиотек

Выведем в отдельный пункт методику создания новых библиотек нодов для других COM-серверов, либо реализация в составе библиотеки нодов определенного COM-интерфейса. 

Как известно, в основном в COM мы имеем дело с интерфейсами и их методами. Также в его составе могут быть enum, методы-события и т.д. Для упрощения создания первичной структуры библиотеки нодов на основе произвольного COM-сервера можно воспользоваться [настоящим проектом](https://github.com/GeorgGrebenyuk/idl2nvp_converter) с подробным описанием использования. К слову, именно с его помощью был сгенерирован большой пакет нодов для nanoCAD. ModelStudio CS, Renga.

# Формирование манифеста

Для успешного импорта библиотеки нодов в среду NVP помимо dll необходимо иметь файл манифеста *`.nodeitem`*. Он представляет собой XML-документ с информацией по каждому из нодов:

```xml
<NodeInfo>
    <!--Идентификатор нода --> 
    <Id>921DB480-C567-419C-B382-37A8ADFBC3D9</Id>
    <!--Наименование dll, где объявлен класс, реализующий нод --> 
    <PathAssembly>NVP_ModelStudio_COM.dll</PathAssembly>
    <!--Полный путь к классу с пространством имён --> 
    <PathExecuteClass>ironObjComLib.WrReinfSpiral.Element</PathExecuteClass>
    <!--Имя разработчика-автора нода --> 
    <CoderName>GeorgGrebenyuk</CoderName>
    <!--Папка в среде NVP, где будет лежать нод. Точки управляют вложенностью групп --> 
    <Folder>NVP_ModelStudio_COM.ironObjComLib.WrReinfSpiral</Folder>
    <!--Отображаемое в NVP имя нода --> 
    <NodeName>Element</NodeName>
    <!--Тип нода. Если Button - то есть кнопка --> 
    <NodeType>Loaded</NodeType>
    <!--Контекст выполнения (для загружаемых в память плагинов, .NET API) --> 
    <CADType>None</CADType>
    <!--Режим отображения нода (только его UI) в зависимости от логики нода--> 
    <ViewType>Data</ViewType>
    <!--Отображаемая подсказка к ноду --> 
    <Text>property Element</Text>
  </NodeInfo>
```

Для небольших наборов нодов можно писать его параллельно в XML файле рядом с кодом, но на больших проектах его оперативное исправление отдельно от правки кода может быть сопряжено с огромными трудозатратами. 

В качестве решения можете воспользоваться методикой, которая успешно применяется на библиотеках набора пакетов нодов `nvp_NodeLibs_ActiveX`. Имеется проект с классом `NVP_Manifest`, содержащим заполняемые атрибуты. Опциональные желательные к заполнению атрибуты -- это Text (подсказка) и ViewType. Остальные могут формироваться автоматически на основе правил чтения dll. Подробнее с логикой чтения можете ознакомиться в классе `Program.cs` проекта `NVP_Manifest_CreatorExe`.
